\chapter{Infrastructura din spatele aplicației}

% ============================================================================================================
\section{Structura proiectului}
% ============================================================================================================
Codul sursă al proiectului este organizat folosind sistemul de version control GIT \cite{GIT_citation} și poate fi direct accesat pe GitHub de către oricine la următorul link \cite{GithubRepository_citation}. Dependețele proiectului sunt gestionate folosind git submodules, o modalitate prin care în repository-ul principal al proiectului sunt păstrate referințe la alte repositories. Astfel, atunci când este folosită comanda \textbf{\mintinline{latex}{git clone --recursive}} pentru repository-ul principal al proiectului, se vor descarcă și dependețele automat în directorul \textit{\texttt{vendor}}. Dependețele proiectului și modul în care acestea sunt integrate în proiect sunt definite în fișierul \textit{\texttt{dependencies.lua}}, responsabil de centralizarea informațiilor referitoare la directoarele de includere \textit{\texttt{IncludeDir}}, directoarele bibliotecilor statice \textit{\texttt{LibraryDir}}, precum și numele bibliotecilor necesare în funcție de platforma alesă. 

Structura de organizare este definită la nivelul scriptului Premake5 \cite{Premake5_citation}, care are rolul de a genera configurațiile corespunzătoare pentru sistemul de build al platformei țintă, asigurând respectarea convențiilor de mai jos. 

Întregul cod sursă al aplicației se regăsește în folderul \textit{\texttt{ParticleSystem/source}} și este compus din fișiere \textit{\texttt{.cpp}} și \textit{\texttt{.h}}, în care este descris modul de operare al sistemului de particule. Implementările fișierelor care definesc funcționalitatea unui shader (unitate programabilă de tip shader rulată exclusiv pe placa video) se regăsesc in directorul \textit{\texttt{ParticleSystem/shaders}} și sunt împarțite în trei tipuri: \textit{\texttt{.comp}} pentru compute shaders; \textit{\texttt{.vert}} pentru vertex shaders; \textit{\texttt{.frag}} pentru fragment shaders. 

Fișierele binare finale rezultate în urma procesului de compilare a codului sursă se vor regăsi în folderul \textit{\texttt{bin}} urmat de subfolderul corespunzător celor două configurații disponibile ale aplicației, \textit{\texttt{Debug-windows-x86\_64}}, respectiv \textit{\texttt{Release-windows-x86\_64}}. Cele două subfoldere conțin la rândul lor un alt subfolder \textit{\texttt{shaders}} în care se regăsesc toate shaders compilate care urmează să fie folosite, cele cinci benchmark-uri predefinite în folderul \textit{\texttt{benchmark}}, alături de executabilul aplicației desktop ParticleSystem în formatul corespunzător pentru Windows \textit{\texttt{.exe}}, respectiv \textit{\texttt{elf}} pentru Linux; și versiunile compilate static ale bibliotecilor ImGui și GLFW, care au ca rezultat un fișier de tipul \textit{\texttt{.lib}} pentru Windows, respectiv \textit{\texttt{.a}} pentru Linux. Fișierele intermediare generate în timpul procesului de compilare a codului sursă se regăsesc în folderul \textit{\texttt{.bin-int}} și respectă structura de subfoldere descrisă anterior. Aceste fișiere au extensia \textit{\texttt{.obj}} pe Windows, respectiv \textit{\texttt{.o}} pe Linux, și conțin codul mașină aferent fiecărui fișier sursă individual, dar care nu a fost încă legat într-un executabil final sau într-o bibliotecă. 

% ============================================================================================================
\section{Automation scripts}
% ============================================================================================================
Pentru a asigura un mediu de dezvoltare eficient și portabil, am creat două script-uri \textit{\texttt{generate\_project}} care se ocupă automat de tot ce înseamnă setup-ul și dependențele necesare proiectului. Pe Windows este folosit un fișier cu formatul \textit{\texttt{.bat}}, iar pe Linux este folosit un fișier cu formatul \textit{\texttt{.sh}}. Cele două script-uri au ca scop executarea automată a următoarelor etape, fără a mai necesita intervenția utilizatorului: descărcarea, instalarea și configurarea Vulkan SDK \cite{VulkanSDK-Windows_citation} \cite{VulkanSDK-Linux_citation}; copierea directoarelor Vulkan \textit{\texttt{include}} și \textit{\texttt{lib}} în directorul principal al proiectului; copierea executabilului \textit{\texttt{glslc.exe}} cu care se compilează toate fișierele sursă pentru shaders; configurarea git hooks; și într-un final, apelarea executabilului premake5. 

% ============================================================================================================
\section{Premake5}
% ============================================================================================================
Premake5 este un instrument de dezvoltare software care asigură generarea fișierelor de configurare și build ale proiectului în funcție de platforma utilizată \cite{Premake5_citation}. În spate sunt definite mai multe fișiere de configurare independente de platformă folosind limbajul de programare Lua \cite{LUA_citation}. În folderul \textit{\texttt{vendor/premake5}}, se regăsesc două executabile de linie de comandă portabile premake5, unul pentru Windows, respectiv Linux. La apelarea acestor executabile, se vor folosi fișierele Lua definite pentru a genera pe Windows fișierele unui proiect care folosește Visual Studio 2022 \cite{VisualStudio-citation}, iar pe Linux fișierele unui proiect care folosește GNU Makefiles \cite{Make_citation}. În generearea noilor fișiere, Premake5 asigură următoarele aspecte: configurarea arhitecturii pe x64; folosirea C++20; crearea configurațiilor de \textit{\texttt{Debug}} și \textit{\texttt{Release}}; includerea în proiect a fișierelor necesare care definesc funcționalitățiile aplicației; legăturile de compilare statică pentru bibliotecile GLFW și ImGui, compilate local; definirea directivelor de preprocesare; adăugarea unui pas suplimentar înaintea tuturor etapelor de build, care indentifică și compilează automat noile schimbări aduse unui fișier ce definește un shader. 

% ============================================================================================================
\section{GIT hooks}
% ============================================================================================================
Există două git hooks, \textit{\texttt{post-checkout}} și \textit{\texttt{post-merge}}, configurate la nivelul proiectului, care vor asigura că de fiecare dată când sunt apelate comenzi de git care pot aduce modificări în structura proiectului, este rulat fișierul de setup \textit{\texttt{generate\_project}}. Astfel se vor regenera toate fișierele de tip build, reflectând mereu ultimele modificări aduse proiectului. În acest mod, automatizarea asigură constant integritatea proiectului. 

% ============================================================================================================
\section{CI/CD Pipeline}
% ============================================================================================================
Pipeline-ul de CI/CD (Continuous Integration / Continuous Delivery) este construit cu ajutorul serviciilor GitHub Actions, care folosesc mașini GitHub-hosted cu Windows și Linux. Pe aceste sisteme este compilat tot codul dezvoltat, garantând în acest mod că noile modificări aduse la nivelul codului sursă sunt mereu compatibile cu ambele platforme. De asemenea, acest pipeline este responsabil și de distribuția aplicației atunci când este publicat un nou git tag. Produsul software final este publicat în secțiunea \textbf{Releases}, care se regăsește pe pagina web principală a proiectului \cite{ReleasesURL_citation}. Astfel, totul poate fi foarte ușor accesat de orice utilizator care își dorește să descarce și să încerce aplicația pe propriul calculator. 

Există 2 fișiere separate în format \textit{\texttt{.yaml}}, unul pentru Windows, și unul pentru Linux, care definesc modul și ordinea în care trebuie efectuate toate etapele din pipeline. Primul pas este cel în care se descarcă codul sursă al proiectului de pe GitHub, urmat de pasul de setup în care este rulat script-ul automat \textit{\texttt{generate\_project}}, responsabil pentru configurarea întregului proiect. Imediat după, vine pasul de build în care este folosit build engine-ul corespunzător platformei țintă, MSBuild pentru Windows \cite{MSBuild_citation}, respectiv Make pentru Linux \cite{Make_citation}, pentru a crea executabilul final al aplicației. Etapele descrise mai sus sunt executate identic atât pentru versiunea Debug, cât și pentru versiunea \textit{\texttt{Release}}, cu mențiunea că se schimbă doar valoarea parametrului \textit{\texttt{build-configuration}}. Ultimul pas din pipeline este realizat doar pentru versiunea Release a aplicației și doar atunci când există un tag nou, ce semnalează faptul că există o nouă actualizare a aplicației ce trebuie distribuită. Pentru acestă etapă, este creat un folder în care sunt copiate toate fișierele de shader compilate, testele de benchmark și executabilul aplicației. Întregul folder este arhivat sub forma unui simplu \textit{\texttt{.zip}} cu numele platformei concatenat cu noul tag, care este încărcat ulterior în secțiunea \textbf{Releases} \cite{ReleasesURL_citation}.




% ============================================================================================================
% TODO: SCRIE
% ============================================================================================================
% - de mentionat ce compilator este folosit pe fiecare platforma
% - MAYBE: pune poza cu cele 2 GIT hooks
% - MAYBE: pune poza cu cele 2 script-uri .yaml

